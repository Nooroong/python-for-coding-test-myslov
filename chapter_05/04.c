/*
1h 2m 9s
c로 짜려니까 큐를 다 손수 구현해야 한다…
그리고 큐 사이즈를 몇으로 설정해야 하는지 모르겠음. 일단 50*50은 성공.

BFS를 이용하는 이유: 칸 수가 최대 200*200 = 40000인데
이걸 DFS로 구현하면 함수가 만 번은 넘게 호출되는 경우가 생김.
파이썬의 경우 재귀 깊이가 1000이라고 한다.
다른 언어의 경우 함수의 길이나 매개변수의 수마다 상이하겠지만
함수 길이가 짧아도 약 5000번 정도 호출되면 스택의 범위를 초과할 수 있다.
그러므로 BFS를 사용할 수 밖에 없다고 생각한다.

(10)
5 6
101010
111111
000001
111111
111111

(19)
10 10
1110101111
1110001111
1110111111
1111101111
0111111111
0001111111
1111100111
1001111111
1011111111
0000111111

(1275)
50 50
11111111111111111111111111111111111111111111111111
00000000000000000000000000000000000000000000000001
11111111111111111111111111111111111111111111111111
10000000000000000000000000000000000000000000000000
11111111111111111111111111111111111111111111111111
00000000000000000000000000000000000000000000000001
11111111111111111111111111111111111111111111111111
10000000000000000000000000000000000000000000000000
11111111111111111111111111111111111111111111111111
00000000000000000000000000000000000000000000000001
11111111111111111111111111111111111111111111111111
10000000000000000000000000000000000000000000000000
11111111111111111111111111111111111111111111111111
00000000000000000000000000000000000000000000000001
11111111111111111111111111111111111111111111111111
10000000000000000000000000000000000000000000000000
11111111111111111111111111111111111111111111111111
00000000000000000000000000000000000000000000000001
11111111111111111111111111111111111111111111111111
10000000000000000000000000000000000000000000000000
11111111111111111111111111111111111111111111111111
00000000000000000000000000000000000000000000000001
11111111111111111111111111111111111111111111111111
10000000000000000000000000000000000000000000000000
11111111111111111111111111111111111111111111111111
00000000000000000000000000000000000000000000000001
11111111111111111111111111111111111111111111111111
10000000000000000000000000000000000000000000000000
11111111111111111111111111111111111111111111111111
00000000000000000000000000000000000000000000000001
11111111111111111111111111111111111111111111111111
10000000000000000000000000000000000000000000000000
11111111111111111111111111111111111111111111111111
00000000000000000000000000000000000000000000000001
11111111111111111111111111111111111111111111111111
10000000000000000000000000000000000000000000000000
11111111111111111111111111111111111111111111111111
00000000000000000000000000000000000000000000000001
11111111111111111111111111111111111111111111111111
10000000000000000000000000000000000000000000000000
11111111111111111111111111111111111111111111111111
00000000000000000000000000000000000000000000000001
11111111111111111111111111111111111111111111111111
10000000000000000000000000000000000000000000000000
11111111111111111111111111111111111111111111111111
00000000000000000000000000000000000000000000000001
11111111111111111111111111111111111111111111111111
10000000000000000000000000000000000000000000000000
11111111111111111111111111111111111111111111111111
00000000000000000000000000000000000000000000000001
*/

#include <stdio.h>
#include <stdlib.h>

// 큐에 좌표정보를 넣기 위한 구조체
typedef struct _node
{
    int x;
    int y;
} Node;

#define QSIZE 200
#define QDATA Node

typedef struct _circlerQueue
{
    Node queArr[QSIZE];
    int front;
    int rear;
    int size;
} Queue;

void QueueInit(Queue * q);
int IsQueueEmpty(Queue * q);
int Enqueue(Queue * q, QDATA data);
int Dequeue(Queue * q, QDATA * data );
int BFS(int ** arr, int row, int col, int rowSize, int colSize);

int main(void)
{
    int n, m;
    int ** maze;
    int i, j;


    scanf("%d %d", &n, &m);
    maze = (int**)malloc(sizeof(int*) * n);
    for(i = 0; i < n; i++)
        maze[i] = (int*)malloc(sizeof(int) * m);

    for(i = 0; i < n; i++)
    {
        for(j = 0; j < m; j++)
            scanf("%1d", &maze[i][j]);
    }

    printf("%d", BFS(maze, 0, 0, n, m)); // 목표지점까지 이동한 거리 출력

    return 0;
}

void QueueInit(Queue * q)
{
    q->front = 0;
    q->rear = 0;
    q->size = 0;
}

int IsQueueEmpty(Queue * q)
{
    if(q->front == q->rear)
        return 1;
    else
        return 0;
}

int IsQueueFull(Queue * q)
{
    if(q->front == ((q->rear)+1)%QSIZE)
        return 1;
    else
        return 0;
}

int Enqueue(Queue * q, QDATA data)
{
    if(IsQueueFull(q))
        return 0;
    else
    {
        q->rear = ((q->rear)+1) % QSIZE;
        q->queArr[q->rear] = data;
        (q->size)++;

        return 1;
    }
}

int Dequeue(Queue * q, QDATA * data )
{
    if(IsQueueEmpty(q))
        return 0;
    else
    {
        q->front = ((q->front)+1) % QSIZE;
        *data = q->queArr[q->front];
        (q->size)--;

        return 1;
    }
}

int BFS(int ** arr, int row, int col, int rowSize, int colSize)
{
    Node node;
    Queue que;
    QueueInit(&que);

    // 상, 하, 좌, 우 이동값.
    int dRow[4] = { -1, 1, 0, 0 };
    int dCol[4] = { 0, 0, -1, 1 };
    int nRow, nCol; // 새롭게 방문할 노드의 좌표값

    int i;

    // 현재 노드 방문 처리
    node.x = row;
    node.y = col;
    Enqueue(&que, node);

    // 큐가 비었다 == 탐색이 완료됐다
    while(!IsQueueEmpty(&que))
    {
        // 탐색을 시작할 노드를 큐에서 뽑음.
        if(Dequeue(&que, &node))
        {
            row = node.x;
            col = node.y;
        }

        // 상, 하, 좌, 우의 위치를 확인.
        for(i = 0; i < 4; i++)
        {
            // 새롭게 방문할 노드의 좌표 계산.
            nRow = row + dRow[i];
            nCol = col + dCol[i];

            if(nRow < 0 || nRow >= rowSize || nCol < 0 || nCol >= colSize) // 범위를 벗어난 경우 패스.
                continue;
            else if(arr[nRow][nCol] == 0) // 벽인 경우 패스.
                continue;
            else if(arr[nRow][nCol] == 1) // 처음 방문하는 곳인 경우, (이미 방문한 곳은 값이 2 이상이다.)
            {
                // 방문할 수 있는 칸은 지나온 횟수를 값으로 갖게 된다.
                // 이전 칸의 거리 + 1을 새롭게 방문한 칸의 값으로 넣는다.
                arr[nRow][nCol] = arr[row][col] + 1;

                // 방문했으므로 해당 좌표를 enqueue
                node.x = nRow;
                node.y = nCol;
                Enqueue(&que, node);
            }

        }
    }

    // 항상 해결할 수 있는 미로만 문제로 주어지기 때문에
    // 골인 지점의 값(= 골인 지점까지 거쳐온 거리)을 리턴해주면 된다.
    return arr[rowSize-1][colSize-1];
}

